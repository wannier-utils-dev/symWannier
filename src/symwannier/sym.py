#!/usr/bin/env python
#
#  Note for symmetry operation
#    s[isym,:,:] @ k          for k-space
#    r @ s[isym,:,:] - ft     for r-space
#

import numpy as np
import itertools

class Sym:
    """
    symmetry information for nscf calculation generated by pw2wannier90.x
    """
    def __init__(self, file_sym):
        self._read_sym_file(file_sym)
        self._kpoint_grid()
        self.uspin_T = np.array([ [0, 1], [-1, 0] ])  # -i sigma_y
        self.uspin_T_inv = np.array([ [0, -1], [1, 0] ])  # (-i sigma_y)^-1

    def _read_sym_file(self, file_sym):
        print("  Reading {}".format(file_sym))
        with open(file_sym) as fp:
            fp.readline()  # skip first line
            self.spinors = "spinors" in fp.readline()  # second line: check spinor

            #
            # read symmetry operation
            #
            nsym = int( fp.readline() )
            print("  num of symmetry ops.: {}".format(nsym))
            s = np.zeros([nsym,3,3], dtype=int)
            ft = np.zeros([nsym,3])
            t_rev = np.zeros([nsym], dtype=int)
            u_spin = np.zeros([nsym,2,2], dtype=complex)
            invs = np.zeros([nsym], dtype=int)
            for isym in range(nsym):
                fp.readline()  # skip sym info
                for a in range(3):
                    s[isym,a,:] = [ int(x) for x in fp.readline().split() ]
                ft[isym,:] = [ float(x) for x in fp.readline().split() ]
                t_rev[isym] = int( fp.readline() )
                if self.spinors:
                    for a in range(2):
                        for b in range(2):
                            d = [ float(x) for x in fp.readline().split() ]
                            u_spin[isym,a,b] = d[0] + 1j * d[1]
                else:
                    u_spin[isym,0,0] = 1
                    u_spin[isym,1,1] = 1
                invs[isym] = int( fp.readline() ) - 1   # invs starts from 0
            time_reversal = bool( fp.readline() )

            #
            # read k-points and setup k-space
            #
            fp.readline()  # skip blank line
            fp.readline()  # skip "K points"
            nk_grid = [ int(x) for x in fp.readline().split() ]
            nk_shift = [ int(x) for x in fp.readline().split() ]
            nks = int( fp.readline() )
            klist = np.zeros([nks,3])
            for ik in range(nks):
                klist[ik,:] = [ float(x) for x in fp.readline().split() ]
            print("  num of irr. k-points: {}".format(nks))

            #
            # read Representation matrix
            #
            fp.readline()  # skip blank line
            fp.readline()  # skip "Representation ..."
            nbnd = int( fp.readline().split()[0] )
            repmat = np.zeros([nks, nsym, nbnd, nbnd], dtype=complex)
            line = fp.readline()
            while len(line) > 2:
                ik, isym = [ int(x) for x in line.split() ]
                ch = [ float(x) for x in fp.readline().split() ]
                #if (ch[0] - round(ch[0])) > 1e-5 or ch[1] > 1e-5:
                #    print("Warning: character is not integer!  {} + {}i".format(ch[0], ch[1]))
                while True:
                    line = fp.readline()
                    d = line.split()
                    if len(d) < 3: break
                    repmat[ ik-1, isym-1, int(d[0])-1, int(d[1])-1 ] = float(d[2]) + 1j * float(d[3])

            #
            # read Rotation matrix
            #
            fp.readline()   # skip "Rotation ..."
            num_wann = int(fp.readline())
            rotmat = np.zeros([nsym, num_wann, num_wann], dtype=complex)
            line = fp.readline()
            while len(line) > 2:
                isym = int(line)
                while True:
                    line = fp.readline()
                    d = line.split()
                    if len(d) < 3: break
                    rotmat[ isym-1, int(d[0])-1, int(d[1])-1 ] = float(d[2]) + 1j * float(d[3])

            self.nsym = nsym
            self.s = s
            self.ft = ft
            self.t_rev = t_rev
            self.u_spin = u_spin
            self.time_reversal = time_reversal
            self.invs = invs
            self.nk_grid = nk_grid
            self.nk_shift = nk_shift
            self.nks = nks
            self.irr_kpoints = klist
            self.nbnd = nbnd
            self.repmat = repmat
            self.rotmat = rotmat

            self._repmat_rescale()

    def _kpoint_grid(self):
        """
        calculate relation between full k-mesh and irreducible k-mesh
        full k-mesh:  full_kpoints[1:nkf,3]
        irr. k-mesh:  irr_kpoints[1:nks,3]
        s[isym] x irr_k[iks] = full_k[ik]
        equiv[ik] = iks
        equiv_sym[ik] = isym
        """
        # full mesh
        kx = np.array([ float(i + 0.5*self.nk_shift[0])/self.nk_grid[0] for i in range(self.nk_grid[0]) ])
        kx = np.where(kx < 0.5, kx, kx-1)
        ky = np.array([ float(i + 0.5*self.nk_shift[1])/self.nk_grid[1] for i in range(self.nk_grid[1]) ])
        ky = np.where(ky < 0.5, ky, ky-1)
        kz = np.array([ float(i + 0.5*self.nk_shift[2])/self.nk_grid[2] for i in range(self.nk_grid[2]) ])
        kz = np.where(kz < 0.5, kz, kz-1)
        full_klist = np.array(list(itertools.product(kx, ky, kz)))
        nkf = np.product(self.nk_grid)
        equiv = - np.ones( [ nkf ], dtype=int )
        equiv_sym = np.zeros( [ nkf ], dtype=int )
        iks2ik = - np.ones([ len(self.irr_kpoints) ], dtype=int )
        for ik, k in enumerate(full_klist):
            for iks, ks in enumerate(self.irr_kpoints):
                kdiff = k - ks
                if np.allclose(kdiff, np.round(kdiff)):
                    iks2ik[iks] = ik
                for isym, s in enumerate(self.s):
                    sks = np.dot(s, ks)
                    if self.t_rev[isym] == 1 : sks = -sks
                    kdiff = sks - k
                    if np.allclose(kdiff, np.round(kdiff)):
                        if equiv[ik] < 0:
                            equiv[ik] = iks
                            equiv_sym[ik] = isym
                            #if np.any(np.abs(kdiff) > 1e-5):
                            #    print("Warning: first isym's kdiff /= 0")
                            #    print(ks)
                            #    print(np.dot(s, ks))
                            #    print(k)
                        elif equiv[ik] == iks:
                            continue
                        else:
                            raise Exception("k corresponds to two different irr. kpoints")
        if np.any(equiv < 0):
            raise Exception("some k points do not correspond to irr. kpoints")
        if np.any(iks2ik < 0):
            print(full_klist)
            print(self.irr_kpoints)
            raise Exception("some irr k points are not in full kpoints")

        self.full_kpoints = full_klist
        self.nkf = nkf
        self.equiv = equiv
        self.equiv_sym = equiv_sym
        self.iks2ik = iks2ik

        #for ik, k in enumerate(self.full_kpoints):
        #    print("ik: {},  equiv[ik]: {},  k= {} {} {}".format(ik, equiv[ik], k[0], k[1], k[2]))


    def kpoint_equiv_info(self, kpoints):
        """
        return equiv
        s[isym] . kpoints[ equiv[ik,isym] ] ~= kpoints[ ik ]
        """
        nk, _ = kpoints.shape
        equiv = - np.ones( [nk, self.nsym], dtype=int )
        for ik1, k1 in enumerate(kpoints):
            for ik2, k2 in enumerate(kpoints):
                for isym, s in enumerate(self.s):
                    sk1 = np.dot(s, k1)
                    if self.t_rev[isym] == 1: sk1 = -sk1
                    kdiff = sk1 - k2
                    #if np.allclose(kdiff, np.round(kdiff), atol=1e-5):
                    if np.all( np.abs(kdiff) < 1e-5 ):
                        equiv[ik2, isym] = ik1
        if np.any(equiv < 0):
            raise Exception("some k points do not correspond to k list")

        return equiv

    def rpoint_equiv_info(self, rpoints):
        """
        return equiv
        s[isym] . rpoints[ir1] + ft[isym] ~= rpoints[ equiv[ir1,isym] ]

        """
        nr, a = rpoints.shape
        equiv = - np.ones( [nr, self.nsym], dtype=int )
        for ir1, r1 in enumerate(rpoints):
            for isym, s in enumerate(self.s):
                r1p = self.apply_r(isym, r1)
                for ir2, r2 in enumerate(rpoints):
                    rdiff = r1p - r2
                    if np.allclose(rdiff, np.round(rdiff), atol=1e-5):
                        equiv[ir1, isym] = ir2
        if np.any(equiv < 0):
            raise Exception("some k points do not correspond to k list")

        return equiv


    def search_ik_full(self, k):
        """
        return ik such that full_kpoints[ik] = k
        """
        for ik, kf in enumerate(self.full_kpoints):
            kdiff = kf - k
            if np.allclose(kdiff, np.round(kdiff), atol=1e-5):
                return ik
        print("k is not found", k)
        return -1

    def apply_r(self, isym, r):
        """
        apply isym-th symmetry for r (r-space vector in crystal coordinate)
        """
        return np.matmul(r, self.s[isym]) - self.ft[isym]

    def apply_inv_r(self, isym, r):
        """
        apply inverse isym-th symmetry for r (r-space vector in crystal coordinate)
        """
        return np.matmul(r + self.ft[isym], self.s[self.invs[isym]])

    def search_symop(self, sym_list):
        # multiply operations in sym_list and search corresponding symmetry operations
        # r' = r s0 - t0
        # r'' = r' s1 - t1 = (r s0 - t0) s 1 - t1 = r s0 s1 - t0 s1 - t1
        #
        # setup s0, t0, u0, t_rev
        s0 = np.eye(3, dtype=int)
        t0 = np.zeros([3])
        u0 = np.eye(2, dtype=complex)
        t_rev = 0
        for [isym, inv] in sym_list:
            if inv > 0:
                # r s - t
                s1 = self.s[isym,:,:]
                t1 = self.ft[isym,:]
                u1 = self.u_spin[isym,:,:]
                if self.t_rev[isym] == 1:
                    u1 = np.matmul(self.uspin_T, np.conj(u1))
            else:
                # inv(r s - t) ==> (r+t) s^-1 = r s^-1 + t s^-1
                s1 = self.s[self.invs[isym],:,:]
                t1 = - np.matmul(self.ft[isym,:], s1)
                u1 = self.u_spin[isym,:,:]
                u1 = np.conj(np.transpose(u1))
                if self.t_rev[isym] == 1:
                    u1 = np.matmul(u1, self.uspin_T_inv)

            s0 = np.matmul(s0, s1)
            t0 = np.matmul(t0, s1) + t1
            if t_rev == 1:
                u1 = np.conj(u1)
            u0 = np.matmul(u0, u1)
            t_rev = (t_rev + self.t_rev[isym]) % 2

        for isym in range(self.nsym):
            tdiff = t0 - self.ft[isym]
            if np.allclose(s0, self.s[isym]) and np.allclose(tdiff, np.round(tdiff), atol=1e-6) and t_rev == self.t_rev[isym]:
                if self.spinors:
                    if t_rev == 1:
                       us = np.matmul(self.uspin_T, np.conj(self.u_spin[isym]))
                    else:
                       us = self.u_spin[isym]
                    #return isym, tdiff
                    if np.allclose(u0, us, atol=1e-5):
                        return isym, 1, tdiff
                    elif np.allclose(u0, -us, atol=1e-5):
                        return isym, -1, tdiff
                    else:
                        print("u_spin does not match")
                        print("isym =", isym)
                        print("u[isym]")
                        print(us)
                        print("u0")
                        print(u0)
                        print(self.t_rev[isym])
                        print(sym_list)
                        for [isym, inv] in sym_list:
                            print(self.u_spin[isym,:,:])
                            print(self.t_rev[isym])
                else:
                    return isym, 1, tdiff
        raise Exception("search_symop failed")

    def _repmat_rescale(self, debug_print=False):
        """
        if the eigen value of repmat is not integer, rescale it
        """
        for ik, isym in itertools.product(range(self.nks), range(self.nsym)):
            for n in range(self.nbnd):
                vall = np.sum(np.abs(self.repmat[ik, isym, n, :]))
                val = np.abs(self.repmat[ik, isym, n, n])
                if np.abs(vall - val) < 1e-8 and (not np.round(val) == 0):
                    if np.abs(np.round(val) - val) > 0.1 and n < self.nbnd-1:
                        print(ik, isym, n, self.repmat[ik,isym,n,n], val, np.round(val))
                    self.repmat[ik, isym, n, n] *= np.round(val)/val

        if debug_print:
            print("new repmat")
            for ik, isym in itertools.product(range(self.nks), range(self.nsym)):
                for m, n in itertools.product(range(self.nbnd), range(self.nbnd)):
                    if self.repmat[ik, isym, m, n] == 0:
                        continue
                    val = self.repmat[ik, isym, m, n]
                    print("{:5d} {:5d} {:5d} {:5d} {:12.6f} {:12.6f}".format(ik, isym, m, n, val.real, val.imag))

